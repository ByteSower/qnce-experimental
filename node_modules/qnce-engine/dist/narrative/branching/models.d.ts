/**
 * Core branching entities for dynamic narrative flow management
 * Built on Sprint #2 performance infrastructure with object pooling support
 */
import { NarrativeNode, QNCEState } from '../../engine/core';
/**
 * Top-level story container with branching metadata
 */
export interface QNCEStory {
    id: string;
    title: string;
    version: string;
    metadata: StoryMetadata;
    chapters: Chapter[];
    branchingConfig: BranchingConfig;
}
export interface StoryMetadata {
    author: string;
    description: string;
    tags: string[];
    createDate: Date;
    lastModified: Date;
    estimatedPlaytime: number;
}
export interface BranchingConfig {
    maxActiveBranches: number;
    branchCacheSize: number;
    enableDynamicInsertion: boolean;
    enableAnalytics: boolean;
    performanceMode: boolean;
}
/**
 * Chapter: Logical grouping of narrative flows with branching points
 */
export interface Chapter {
    id: string;
    title: string;
    description?: string;
    flows: NarrativeFlow[];
    branches: BranchPoint[];
    prerequisites?: ChapterPrerequisites;
    metadata: ChapterMetadata;
}
export interface ChapterPrerequisites {
    requiredFlags: Record<string, unknown>;
    requiredChoices: string[];
    minPlaytime?: number;
}
export interface ChapterMetadata {
    difficulty: 'easy' | 'medium' | 'hard';
    themes: string[];
    estimatedDuration: number;
    branchComplexity: number;
}
/**
 * NarrativeFlow: Sequence of connected nodes with entry/exit points
 */
export interface NarrativeFlow {
    id: string;
    name: string;
    description?: string;
    nodes: NarrativeNode[];
    entryPoints: FlowEntryPoint[];
    exitPoints: FlowExitPoint[];
    flowType: FlowType;
    metadata: FlowMetadata;
}
export type FlowType = 'linear' | 'branching' | 'conditional' | 'procedural';
export interface FlowEntryPoint {
    id: string;
    nodeId: string;
    conditions?: BranchCondition[];
    priority: number;
}
export interface FlowExitPoint {
    id: string;
    nodeId: string;
    targetFlowId?: string;
    conditions?: BranchCondition[];
}
export interface FlowMetadata {
    complexity: number;
    avgCompletionTime: number;
    playerChoiceCount: number;
    aiGeneratedContent: boolean;
}
/**
 * BranchPoint: Dynamic branching logic between flows
 */
export interface BranchPoint {
    id: string;
    name: string;
    sourceFlowId: string;
    sourceNodeId: string;
    branchOptions: BranchOption[];
    branchType: BranchType;
    conditions?: BranchCondition[];
    metadata: BranchMetadata;
}
export type BranchType = 'choice-driven' | 'flag-conditional' | 'time-based' | 'procedural' | 'conditional';
export interface BranchOption {
    id: string;
    targetFlowId: string;
    targetNodeId?: string;
    displayText: string;
    conditions?: BranchCondition[];
    flagEffects?: Record<string, unknown>;
    weight: number;
}
export interface BranchCondition {
    type: 'flag' | 'choice' | 'time' | 'random' | 'custom';
    operator: 'equals' | 'not_equals' | 'greater' | 'less' | 'contains' | 'exists';
    key: string;
    value: unknown;
    evaluator?: (state: QNCEState, context: BranchContext) => boolean;
}
export interface BranchMetadata {
    usageCount: number;
    avgTraversalTime: number;
    playerPreference: number;
    lastUsed: Date;
}
/**
 * BranchContext: Runtime state for branch evaluation and tracking
 */
export interface BranchContext {
    currentStory: QNCEStory;
    currentChapter: Chapter;
    currentFlow: NarrativeFlow;
    activeState: QNCEState;
    branchHistory: BranchHistoryEntry[];
    pendingBranches: PendingBranch[];
    analytics: BranchAnalytics;
}
export interface BranchHistoryEntry {
    id: string;
    branchPointId: string;
    chosenOptionId: string;
    timestamp: Date;
    executionTime: number;
    context: Partial<QNCEState>;
}
export interface PendingBranch {
    id: string;
    branchPointId: string;
    triggerConditions: BranchCondition[];
    timeoutMs?: number;
    createdAt: Date;
}
export interface BranchAnalytics {
    totalBranchesTraversed: number;
    avgBranchDecisionTime: number;
    mostPopularBranches: string[];
    abandonmentPoints: string[];
    completionRate: number;
    sessionStartTime: Date;
}
/**
 * Dynamic branching operations for runtime story modification
 */
export interface DynamicBranchOperation {
    type: 'insert' | 'remove' | 'modify';
    branchId: string;
    targetLocation: BranchLocation;
    payload?: Partial<BranchPoint>;
    conditions?: BranchCondition[];
}
export interface BranchLocation {
    chapterId: string;
    flowId: string;
    nodeId: string;
    insertionPoint: 'before' | 'after' | 'replace';
}
/**
 * Dynamic flow insertion for procedural content
 */
export interface DynamicFlowOperation {
    type: 'insert' | 'remove' | 'modify';
    flowId: string;
    targetChapterId: string;
    flow?: NarrativeFlow;
    entryConditions?: BranchCondition[];
}
/**
 * Pool-aware branch entities for performance optimization
 */
export interface PooledBranchContext extends BranchContext {
    poolId: string;
    acquisitionTime: number;
    maxLifetime: number;
}
export interface PooledBranchPoint extends BranchPoint {
    poolId: string;
    activeReferences: number;
    lastAccessed: number;
}
/**
 * Interfaces for AI-driven content generation and branching
 */
export interface AIBranchingContext {
    playerProfile: PlayerProfile;
    narrativeContext: NarrativeContext;
    generationHints: AIGenerationHints;
}
export interface PlayerProfile {
    playStyle: 'explorer' | 'achiever' | 'socializer' | 'killer';
    preferences: Record<string, number>;
    historicalChoices: string[];
    averageDecisionTime: number;
}
export interface NarrativeContext {
    currentTone: string;
    thematicElements: string[];
    characterRelationships: Record<string, number>;
    plotTension: number;
}
export interface AIGenerationHints {
    maxBranchDepth: number;
    desiredComplexity: number;
    contentThemes: string[];
    avoidElements: string[];
}
//# sourceMappingURL=models.d.ts.map