"use strict";
// QNCE Core Engine - Framework Agnostic
// Quantum Narrative Convergence Engine
Object.defineProperty(exports, "__esModule", { value: true });
exports.QNCEEngine = void 0;
exports.createQNCEEngine = createQNCEEngine;
exports.loadStoryData = loadStoryData;
const ObjectPool_1 = require("../performance/ObjectPool");
const ThreadPool_1 = require("../performance/ThreadPool");
const PerfReporter_1 = require("../performance/PerfReporter");
// Branching system imports
const branching_1 = require("../narrative/branching");
// Demo narrative data moved to demo-story.ts
function findNode(nodes, id) {
    const node = nodes.find(n => n.id === id);
    if (!node)
        throw new Error(`Node not found: ${id}`);
    return node;
}
/**
 * QNCE Engine - Core narrative state management
 * Framework agnostic implementation with object pooling integration
 */
class QNCEEngine {
    state;
    storyData;
    activeFlowEvents = [];
    performanceMode = false;
    enableProfiling = false;
    branchingEngine;
    constructor(storyData, initialState, performanceMode = false, threadPoolConfig) {
        this.storyData = storyData;
        this.performanceMode = performanceMode;
        this.enableProfiling = performanceMode; // Enable profiling with performance mode
        // Initialize ThreadPool if in performance mode
        if (this.performanceMode && threadPoolConfig) {
            (0, ThreadPool_1.getThreadPool)(threadPoolConfig);
        }
        this.state = {
            currentNodeId: initialState?.currentNodeId || storyData.initialNodeId,
            flags: initialState?.flags || {},
            history: initialState?.history || [storyData.initialNodeId],
        };
    }
    getCurrentNode() {
        const cacheKey = `node-${this.state.currentNodeId}`;
        // Profiling: Record cache operation
        if (this.enableProfiling) {
            const found = findNode(this.storyData.nodes, this.state.currentNodeId);
            PerfReporter_1.perf.cacheHit(cacheKey, { nodeId: this.state.currentNodeId });
            return found;
        }
        if (this.performanceMode) {
            // Use pooled node for enhanced node data
            const pooledNode = ObjectPool_1.poolManager.borrowNode();
            const coreNode = findNode(this.storyData.nodes, this.state.currentNodeId);
            pooledNode.initialize(coreNode.id, coreNode.text, coreNode.choices);
            // Return the pooled node (caller should return it when done)
            return {
                id: pooledNode.id,
                text: pooledNode.text,
                choices: pooledNode.choices
            };
        }
        return findNode(this.storyData.nodes, this.state.currentNodeId);
    }
    getState() {
        return { ...this.state };
    }
    getFlags() {
        return { ...this.state.flags };
    }
    getHistory() {
        return [...this.state.history];
    }
    selectChoice(choice) {
        // S2-T4: Add state transition profiling
        const transitionSpanId = this.enableProfiling
            ? (0, PerfReporter_1.getPerfReporter)().startSpan('state-transition', {
                fromNodeId: this.state.currentNodeId,
                toNodeId: choice.nextNodeId,
                hasEffects: !!choice.flagEffects
            })
            : null;
        const fromNodeId = this.state.currentNodeId;
        const toNodeId = choice.nextNodeId;
        // Create flow event for tracking narrative progression
        if (this.performanceMode) {
            const flowSpanId = this.enableProfiling
                ? PerfReporter_1.perf.flowStart(fromNodeId, { toNodeId })
                : null;
            const flowEvent = this.createFlowEvent(fromNodeId, toNodeId, choice.flagEffects);
            this.recordFlowEvent(flowEvent);
            // Return the flow immediately after recording (we don't need to keep it)
            // This ensures proper pool recycling
            ObjectPool_1.poolManager.returnFlow(flowEvent);
            if (flowSpanId) {
                PerfReporter_1.perf.flowComplete(flowSpanId, toNodeId, { transitionType: 'choice' });
            }
        }
        this.state.currentNodeId = choice.nextNodeId;
        this.state.history.push(choice.nextNodeId);
        if (choice.flagEffects) {
            this.state.flags = { ...this.state.flags, ...choice.flagEffects };
            // S2-T4: Track flag updates
            if (this.enableProfiling) {
                PerfReporter_1.perf.record('custom', {
                    flagCount: Object.keys(choice.flagEffects).length,
                    nodeId: toNodeId,
                    eventType: 'flag-update'
                });
            }
        }
        // Complete state transition span
        if (transitionSpanId) {
            (0, PerfReporter_1.getPerfReporter)().endSpan(transitionSpanId, {
                historyLength: this.state.history.length,
                flagCount: Object.keys(this.state.flags).length
            });
        }
        // S2-T2: Background operations after state change
        if (this.performanceMode) {
            // Preload next possible nodes in background
            this.preloadNextNodes().catch(error => {
                console.warn('[QNCE] Background preload failed:', error.message);
            });
            // Write telemetry data in background  
            this.backgroundTelemetryWrite({
                action: 'choice-selected',
                fromNodeId,
                toNodeId,
                choiceText: choice.text.slice(0, 50) // First 50 chars for privacy
            }).catch(error => {
                console.warn('[QNCE] Background telemetry failed:', error.message);
            });
        }
    }
    resetNarrative() {
        // Clean up pooled objects before reset
        if (this.performanceMode) {
            this.cleanupPools();
        }
        this.state.currentNodeId = this.storyData.initialNodeId;
        this.state.flags = {};
        this.state.history = [this.storyData.initialNodeId];
    }
    loadState(state) {
        this.state = { ...state };
    }
    // Utility method for checking flag conditions
    checkFlag(flagName, expectedValue) {
        if (expectedValue === undefined) {
            return this.state.flags[flagName] !== undefined;
        }
        return this.state.flags[flagName] === expectedValue;
    }
    // Get available choices (with potential flag-based filtering)
    getAvailableChoices() {
        const currentNode = this.getCurrentNode();
        return currentNode.choices.filter(() => {
            // Future: Add flag-based choice filtering logic here
            return true;
        });
    }
    // Performance and object pooling methods
    /**
     * Create a flow event using pooled objects for performance tracking
     */
    createFlowEvent(fromNodeId, toNodeId, metadata) {
        const flow = ObjectPool_1.poolManager.borrowFlow();
        flow.initialize(fromNodeId, metadata);
        flow.addTransition(fromNodeId, toNodeId);
        return flow;
    }
    /**
     * Record and manage flow events
     */
    recordFlowEvent(flow) {
        const flowEvent = {
            id: `${flow.nodeId}-${Date.now()}`,
            fromNodeId: flow.nodeId,
            toNodeId: flow.transitions[flow.transitions.length - 1]?.split('->')[1] || '',
            timestamp: flow.timestamp,
            metadata: flow.metadata
        };
        this.activeFlowEvents.push(flowEvent);
        // Clean up old flow events (basic LRU-style cleanup)
        if (this.activeFlowEvents.length > 10) {
            this.activeFlowEvents.shift(); // Remove oldest
        }
    }
    /**
     * Get current flow events (for debugging/monitoring)
     */
    getActiveFlows() {
        return [...this.activeFlowEvents];
    }
    /**
     * Get object pool statistics for performance monitoring
     */
    getPoolStats() {
        return this.performanceMode ? ObjectPool_1.poolManager.getAllStats() : null;
    }
    /**
     * Return all pooled objects (cleanup method)
     */
    cleanupPools() {
        // Clear flow events (no pooled objects to return since we return them immediately)
        this.activeFlowEvents.length = 0;
    }
    // S2-T2: Background ThreadPool Operations
    /**
     * Preload next possible nodes in background using ThreadPool
     */
    async preloadNextNodes(choice) {
        if (!this.performanceMode)
            return;
        const threadPool = (0, ThreadPool_1.getThreadPool)();
        const currentNode = this.getCurrentNode();
        const choicesToPreload = choice ? [choice] : currentNode.choices;
        // Submit background jobs for each node to preload
        for (const ch of choicesToPreload) {
            threadPool.submitJob('cache-load', { nodeId: ch.nextNodeId }, 'normal').catch(error => {
                if (this.enableProfiling) {
                    PerfReporter_1.perf.record('cache-miss', {
                        nodeId: ch.nextNodeId,
                        error: error.message,
                        jobType: 'preload'
                    });
                }
            });
        }
    }
    /**
     * Write telemetry data in background using ThreadPool
     */
    async backgroundTelemetryWrite(eventData) {
        if (!this.performanceMode || !this.enableProfiling)
            return;
        const threadPool = (0, ThreadPool_1.getThreadPool)();
        const telemetryData = {
            timestamp: performance.now(),
            sessionId: this.state.history[0], // Use first node as session ID
            eventData,
            stateSnapshot: {
                nodeId: this.state.currentNodeId,
                flagCount: Object.keys(this.state.flags).length,
                historyLength: this.state.history.length
            }
        };
        threadPool.submitJob('telemetry-write', telemetryData, 'low').catch(error => {
            console.warn('[QNCE] Telemetry write failed:', error.message);
        });
    }
    // ================================
    // Sprint #3: Advanced Branching System Integration
    // ================================
    /**
     * Enable advanced branching capabilities for this story
     * Integrates the QNCE Branching API with the core engine
     */
    enableBranching(story) {
        if (this.branchingEngine) {
            console.warn('[QNCE] Branching already enabled for this engine instance');
            return this.branchingEngine;
        }
        // Create branching engine with current state
        this.branchingEngine = (0, branching_1.createBranchingEngine)(story, this.state);
        if (this.enableProfiling) {
            PerfReporter_1.perf.record('custom', {
                eventType: 'branching-enabled',
                storyId: story.id,
                chapterCount: story.chapters.length,
                performanceMode: this.performanceMode
            });
        }
        return this.branchingEngine;
    }
    /**
     * Get the branching engine if enabled
     */
    getBranchingEngine() {
        return this.branchingEngine;
    }
    /**
     * Check if branching is enabled
     */
    isBranchingEnabled() {
        return !!this.branchingEngine;
    }
    /**
     * Sync core engine state with branching engine
     * Call this when core state changes to keep branching engine updated
     */
    syncBranchingState() {
        if (this.branchingEngine) {
            // The branching engine maintains its own state copy
            // This method could be extended to sync state changes
            if (this.enableProfiling) {
                PerfReporter_1.perf.record('custom', {
                    eventType: 'branching-state-synced',
                    currentNodeId: this.state.currentNodeId
                });
            }
        }
    }
    /**
     * Disable branching and cleanup resources
     */
    disableBranching() {
        if (this.branchingEngine) {
            this.branchingEngine = undefined;
            if (this.enableProfiling) {
                PerfReporter_1.perf.record('custom', {
                    eventType: 'branching-disabled'
                });
            }
        }
    }
    /**
     * Background cache warming for story data
     */
    async warmCache() {
        if (!this.performanceMode)
            return;
        const threadPool = (0, ThreadPool_1.getThreadPool)();
        // Cache all nodes in background
        const cacheWarmData = {
            nodeIds: this.storyData.nodes.map(n => n.id),
            storyId: this.storyData.initialNodeId
        };
        if (this.enableProfiling) {
            PerfReporter_1.perf.record('custom', {
                eventType: 'cache-warm-start',
                nodeCount: this.storyData.nodes.length
            });
        }
        threadPool.submitJob('cache-load', cacheWarmData, 'low').catch(error => {
            if (this.enableProfiling) {
                PerfReporter_1.perf.record('custom', {
                    eventType: 'cache-warm-failed',
                    error: error.message
                });
            }
        });
    }
}
exports.QNCEEngine = QNCEEngine;
/**
 * Factory function to create a QNCE engine instance
 */
function createQNCEEngine(storyData, initialState, performanceMode = false) {
    return new QNCEEngine(storyData, initialState, performanceMode);
}
/**
 * Load story data from JSON
 */
function loadStoryData(jsonData) {
    // Add validation here in the future
    return jsonData;
}
//# sourceMappingURL=core.js.map