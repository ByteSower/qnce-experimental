import { ThreadPoolConfig } from '../performance/ThreadPool';
import { QNCEBranchingEngine } from '../narrative/branching';
import { QNCEStory } from '../narrative/branching/models';
export interface Choice {
    text: string;
    nextNodeId: string;
    flagEffects?: Record<string, unknown>;
}
export interface NarrativeNode {
    id: string;
    text: string;
    choices: Choice[];
}
export interface QNCEState {
    currentNodeId: string;
    flags: Record<string, unknown>;
    history: string[];
}
export interface FlowEvent {
    id: string;
    fromNodeId: string;
    toNodeId: string;
    timestamp: number;
    metadata?: Record<string, unknown>;
}
export interface StoryData {
    nodes: NarrativeNode[];
    initialNodeId: string;
}
/**
 * QNCE Engine - Core narrative state management
 * Framework agnostic implementation with object pooling integration
 */
export declare class QNCEEngine {
    private state;
    private storyData;
    private activeFlowEvents;
    private performanceMode;
    private enableProfiling;
    private branchingEngine?;
    constructor(storyData: StoryData, initialState?: Partial<QNCEState>, performanceMode?: boolean, threadPoolConfig?: Partial<ThreadPoolConfig>);
    getCurrentNode(): NarrativeNode;
    getState(): QNCEState;
    getFlags(): Record<string, unknown>;
    getHistory(): string[];
    selectChoice(choice: Choice): void;
    resetNarrative(): void;
    loadState(state: QNCEState): void;
    checkFlag(flagName: string, expectedValue?: unknown): boolean;
    getAvailableChoices(): Choice[];
    /**
     * Create a flow event using pooled objects for performance tracking
     */
    private createFlowEvent;
    /**
     * Record and manage flow events
     */
    private recordFlowEvent;
    /**
     * Get current flow events (for debugging/monitoring)
     */
    getActiveFlows(): FlowEvent[];
    /**
     * Get object pool statistics for performance monitoring
     */
    getPoolStats(): {
        flows: {
            poolSize: number;
            maxSize: number;
            created: number;
            borrowed: number;
            returned: number;
            inUse: number;
            hitRate: number;
        };
        nodes: {
            poolSize: number;
            maxSize: number;
            created: number;
            borrowed: number;
            returned: number;
            inUse: number;
            hitRate: number;
        };
        assets: {
            poolSize: number;
            maxSize: number;
            created: number;
            borrowed: number;
            returned: number;
            inUse: number;
            hitRate: number;
        };
    } | null;
    /**
     * Return all pooled objects (cleanup method)
     */
    private cleanupPools;
    /**
     * Preload next possible nodes in background using ThreadPool
     */
    preloadNextNodes(choice?: Choice): Promise<void>;
    /**
     * Write telemetry data in background using ThreadPool
     */
    backgroundTelemetryWrite(eventData: Record<string, unknown>): Promise<void>;
    /**
     * Enable advanced branching capabilities for this story
     * Integrates the QNCE Branching API with the core engine
     */
    enableBranching(story: QNCEStory): QNCEBranchingEngine;
    /**
     * Get the branching engine if enabled
     */
    getBranchingEngine(): QNCEBranchingEngine | undefined;
    /**
     * Check if branching is enabled
     */
    isBranchingEnabled(): boolean;
    /**
     * Sync core engine state with branching engine
     * Call this when core state changes to keep branching engine updated
     */
    syncBranchingState(): void;
    /**
     * Disable branching and cleanup resources
     */
    disableBranching(): void;
    /**
     * Background cache warming for story data
     */
    warmCache(): Promise<void>;
}
/**
 * Factory function to create a QNCE engine instance
 */
export declare function createQNCEEngine(storyData: StoryData, initialState?: Partial<QNCEState>, performanceMode?: boolean): QNCEEngine;
/**
 * Load story data from JSON
 */
export declare function loadStoryData(jsonData: unknown): StoryData;
//# sourceMappingURL=core.d.ts.map