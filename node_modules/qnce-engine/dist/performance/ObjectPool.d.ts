export interface Poolable {
    reset(): void;
    isInUse(): boolean;
    setInUse(inUse: boolean): void;
}
export interface PoolableConstructor<T extends Poolable> {
    new (): T;
}
/**
 * Generic Object Pool for QNCE narrative objects
 * Reduces GC pressure by reusing objects instead of creating new ones
 */
export declare class ObjectPool<T extends Poolable> {
    private pool;
    private createFn;
    private maxSize;
    private created;
    private borrowed;
    private returned;
    constructor(createFn: () => T, initialSize?: number, maxSize?: number);
    /**
     * Borrow an object from the pool
     */
    borrow(): T;
    /**
     * Return an object to the pool
     */
    return(obj: T): void;
    /**
     * Get pool statistics for monitoring
     */
    getStats(): {
        poolSize: number;
        maxSize: number;
        created: number;
        borrowed: number;
        returned: number;
        inUse: number;
        hitRate: number;
    };
    /**
     * Clear the pool (useful for testing)
     */
    clear(): void;
    /**
     * Resize the pool
     */
    resize(newSize: number): void;
}
/**
 * Pooled Flow object for narrative state management
 */
export declare class PooledFlow implements Poolable {
    private _inUse;
    nodeId: string;
    timestamp: number;
    metadata: Record<string, unknown>;
    transitions: string[];
    constructor();
    reset(): void;
    isInUse(): boolean;
    setInUse(inUse: boolean): void;
    initialize(nodeId: string, metadata?: Record<string, unknown>): void;
    addTransition(fromNodeId: string, toNodeId: string): void;
    getDuration(): number;
}
/**
 * Pooled Node object for narrative content
 */
export declare class PooledNode implements Poolable {
    private _inUse;
    id: string;
    text: string;
    choices: unknown[];
    flags: Record<string, unknown>;
    lastAccessed: number;
    constructor();
    reset(): void;
    isInUse(): boolean;
    setInUse(inUse: boolean): void;
    initialize(id: string, text: string, choices?: unknown[]): void;
    touch(): void;
}
/**
 * Pooled Asset object for narrative resources
 */
export declare class PooledAsset implements Poolable {
    private _inUse;
    id: string;
    type: string;
    data: unknown;
    size: number;
    loaded: boolean;
    constructor();
    reset(): void;
    isInUse(): boolean;
    setInUse(inUse: boolean): void;
    initialize(id: string, type: string, data: unknown): void;
    private calculateSize;
}
/**
 * Pool Manager - Centralized management of all object pools
 */
export declare class PoolManager {
    private static instance;
    private flowPool;
    private nodePool;
    private assetPool;
    private constructor();
    static getInstance(): PoolManager;
    borrowFlow(): PooledFlow;
    returnFlow(flow: PooledFlow): void;
    borrowNode(): PooledNode;
    returnNode(node: PooledNode): void;
    borrowAsset(): PooledAsset;
    returnAsset(asset: PooledAsset): void;
    getAllStats(): {
        flows: {
            poolSize: number;
            maxSize: number;
            created: number;
            borrowed: number;
            returned: number;
            inUse: number;
            hitRate: number;
        };
        nodes: {
            poolSize: number;
            maxSize: number;
            created: number;
            borrowed: number;
            returned: number;
            inUse: number;
            hitRate: number;
        };
        assets: {
            poolSize: number;
            maxSize: number;
            created: number;
            borrowed: number;
            returned: number;
            inUse: number;
            hitRate: number;
        };
    };
    getGCPressureReduction(): number;
    clearAllPools(): void;
}
export declare const poolManager: PoolManager;
//# sourceMappingURL=ObjectPool.d.ts.map