#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const core_js_1 = require("../engine/core.js");
/**
 * QNCE Audit CLI Tool
 * Validates narrative structure and checks for loops, dead ends, etc.
 */
function auditStory(filePath) {
    try {
        console.log(`üîç Auditing QNCE story: ${filePath}`);
        const jsonData = JSON.parse((0, fs_1.readFileSync)(filePath, 'utf-8'));
        const storyData = (0, core_js_1.loadStoryData)(jsonData);
        // Basic validation
        console.log(`üìñ Story contains ${storyData.nodes.length} nodes`);
        console.log(`üöÄ Initial node: ${storyData.initialNodeId}`);
        // Check for missing nodes
        const nodeIds = new Set(storyData.nodes.map(n => n.id));
        const referencedIds = new Set();
        storyData.nodes.forEach(node => {
            node.choices.forEach(choice => {
                referencedIds.add(choice.nextNodeId);
            });
        });
        // Find dead ends
        const deadEnds = storyData.nodes.filter(node => node.choices.length === 0);
        console.log(`üîö Dead ends found: ${deadEnds.length}`);
        deadEnds.forEach(node => console.log(`   - ${node.id}: "${node.text.slice(0, 50)}..."`));
        // Find missing node references
        const missingNodes = Array.from(referencedIds).filter(id => !nodeIds.has(id));
        if (missingNodes.length > 0) {
            console.log(`‚ùå Missing nodes referenced:`);
            missingNodes.forEach(id => console.log(`   - ${id}`));
        }
        else {
            console.log(`‚úÖ All node references are valid`);
        }
        // Find unreachable nodes
        const reachableIds = new Set();
        const toVisit = [storyData.initialNodeId];
        while (toVisit.length > 0) {
            const currentId = toVisit.pop();
            if (reachableIds.has(currentId))
                continue;
            reachableIds.add(currentId);
            const node = storyData.nodes.find(n => n.id === currentId);
            if (node) {
                node.choices.forEach(choice => {
                    if (!reachableIds.has(choice.nextNodeId)) {
                        toVisit.push(choice.nextNodeId);
                    }
                });
            }
        }
        const unreachableNodes = storyData.nodes.filter(node => !reachableIds.has(node.id));
        if (unreachableNodes.length > 0) {
            console.log(`‚ö†Ô∏è  Unreachable nodes found: ${unreachableNodes.length}`);
            unreachableNodes.forEach(node => console.log(`   - ${node.id}`));
        }
        else {
            console.log(`‚úÖ All nodes are reachable`);
        }
        console.log(`‚ú® Audit complete!`);
    }
    catch (error) {
        console.error(`‚ùå Error auditing story:`, error);
        process.exit(1);
    }
}
// CLI entry point
const filePath = process.argv[2];
if (!filePath) {
    console.log('Usage: qnce-audit <story-file.json>');
    process.exit(1);
}
auditStory(filePath);
//# sourceMappingURL=audit.js.map